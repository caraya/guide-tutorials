<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Tutorial: CSS @function</title>
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-solarizedlight.min.css" rel="stylesheet">
    <style>
        /*
        * In this tutorial, we are exploring the new CSS @function at-rule.
        * This feature allows for the creation of custom functions directly in CSS,
        * making stylesheets more dynamic, reusable, and organized.
        *
        * Browser Support Note: This is an experimental feature and is currently
        * only supported in Chrome 139+
        */

        /*
        * @function --generate-shade:
        * This function takes a base color and a percentage, then mixes it with black
        * to create a darker shade. It's great for generating color palettes.
        * --base-color: The starting color.
        * --percentage: How much black to mix in.
        */
        @function --generate-shade(--base-color, --percentage) {
            result: color-mix(in srgb, var(--base-color), black var(--percentage));
        }

        /*
        * @function --generate-tint:
        * Similar to the shade function, but this one mixes the base color with white
        * to create a lighter tint.
        * --base-color: The starting color.
        * --percentage: How much white to mix in.
        */
        @function --generate-tint(--base-color, --percentage) {
            result: color-mix(in srgb, var(--base-color), white var(--percentage));
        }

        /*
        * @function --calculate-spacing:
        * This function takes a base spacing unit and a multiplier to create
        * a consistent, scalable spacing system.
        * --base-unit: The base spacing value (e.g., 1rem).
        * --multiplier: The factor to scale the base unit by.
        */
        @function --calculate-spacing(--base-unit, --multiplier) {
            result: calc(var(--base-unit) * var(--multiplier));
        }

        /*
        * @function --fluid-typography:
        * Creates a fluid font size that scales between a min and max size
        * based on the viewport width.
        * --min-size: The minimum font size.
        * --max-size: The maximum font size.
        * --min-vw: The viewport width at which the min font size is applied.
        * --max-vw: The viewport width at which the max font size is applied.
        */
        @function --fluid-typography(--min-size, --max-size, --min-vw, --max-vw) {
            result: clamp(var(--min-size),
                           calc(var(--min-size) + (var(--max-size) - var(--min-size)) * ((100vw - var(--min-vw)) / (var(--max-vw) - var(--min-vw)))),
                           var(--max-size));
        }

        /* Formal Syntax Example Function */
        /* CORRECTION: The current implementation does not support typed parameters OR default values.
           We remove them for the function to be valid. The function now requires all arguments. */
        @function --create-styled-border(--width, --style, --color) {
            result: var(--width) var(--style) var(--color);
        }


        body {
            font-family: 'Inter', sans-serif;
            /* We set the base color and spacing unit here using custom properties */
            --base-color: #3b82f6;
            --base-spacing: 1rem; /* 16px */
        }

        /* Applying the functions to create our theme */
        .themed {
            --primary-color: var(--base-color);
            --primary-color-dark: --generate-shade(var(--base-color), 20%);
            --primary-color-light: --generate-tint(var(--base-color), 20%);
            --primary-color-lighter: --generate-tint(var(--base-color), 80%);
        }

        /* Applying the spacing function */
        .dynamic-spacing {
            --spacing-sm: --calculate-spacing(var(--base-spacing), 0.5); /* resolves to 8px */
            --spacing-md: var(--base-spacing); /* 16px */
            --spacing-lg: --calculate-spacing(var(--base-spacing), 2); /* resolves to 32px */
            --spacing-xl: --calculate-spacing(var(--base-spacing), 4); /* resolves to 64px */
        }

        /* Applying the fluid typography function */
        .fluid-text-container {
            --fluid-font-size: --fluid-typography(1rem, 3rem, 320px, 1200px);
            font-size: var(--fluid-font-size);
        }

        /* Applying the formal syntax example function */
        .styled-border-example-1 {
            border: --create-styled-border(2px, solid, crimson);
        }
        .styled-border-example-2 {
            border: --create-styled-border(5px, dashed, limegreen);
        }
        
        /* Custom styles for Prism.js to match the page */
        pre[class*="language-"] {
            border-radius: 0.5rem;
            border: 1px solid #e5e7eb;
        }

    </style>
</head>
<body class="bg-gray-100 text-gray-800 p-4 sm:p-8">

    <div class="max-w-5xl mx-auto bg-white rounded-2xl shadow-lg p-8 prose lg:prose-xl">

        <header class="text-center mb-12 not-prose">
            <h1 class="text-4xl md:text-5xl font-bold text-gray-900 mb-2">Deep Dive: CSS `@function`</h1>
            <p class="text-lg text-gray-600">An interactive tutorial on the future of dynamic CSS.</p>
            <div class="mt-6 p-6 bg-yellow-50 border-l-4 border-yellow-400">
                <div class="flex">
                    <div class="flex-shrink-0">
                        <svg class="h-6 w-6 text-yellow-400" fill="currentColor" viewBox="0 0 20 20">
                            <path fill-rule="evenodd" d="M8.257 3.099c.765-1.36 2.722-1.36 3.486 0l5.58 9.92c.75 1.334-.21 3.03-1.742 3.03H4.42c-1.532 0-2.492-1.696-1.742-3.03l5.58-9.92zM10 13a1 1 0 110-2 1 1 0 010 2zm-1-4a1 1 0 011-1h.01a1 1 0 110 2H10a1 1 0 01-1-1z" clip-rule="evenodd"/>
                        </svg>
                    </div>
                    <div class="ml-3">
                        <p class="text-lg font-bold text-yellow-800">Browser Support Warning</p>
                        <div class="mt-2 text-md text-yellow-700">
                            <p>The <code>@function</code> at-rule is an <strong>experimental feature</strong>. As of now, it is only supported in <strong>Chrome 139+</strong> and is not available in other browsers like Firefox, Safari, or Edge.</p>
                        </div>
                    </div>
                </div>
            </div>
        </header>

        <!-- Section 1: Introduction -->
        <section class="mb-12">
            <h2>What is `@function`?</h2>
            <p>
                The `@function` at-rule introduces the ability to define custom functions directly within your CSS. Think of them like JavaScript functions, but for your styles. They can take arguments, perform calculations, and return a value. This opens up a new world of possibilities for creating more maintainable, powerful, and dynamic stylesheets without relying on pre-processors like Sass.
            </p>
            <h3>Formal Syntax</h3>
            <p>According to the CSSWG draft, the formal syntax is more robust than a simple function. It allows for typed arguments, default values, and an explicit return type.</p>
<pre><code class="language-css">
@function --function-name(--arg1 <type> = default, --arg2) returns <type> {
  /* Function body with logic */
  result: /* some computed value */;
}
</code></pre>
            <ul>
                <li><strong><code>--function-name</code></strong>: The name you'll use to call the function, e.g., <code>--my-function()</code>.</li>
                <li><strong><code>--arg1 &lt;type&gt; = default</code></strong>: An argument. You can specify a type (like <code>&lt;length&gt;</code> or <code>&lt;color&gt;</code>) and provide a default value.</li>
                <li><strong><code>returns &lt;type&gt;</code></strong>: This is the <strong>declaration</strong>. It's an optional keyword that tells the browser what <em>type</em> of value you expect the function to output (e.g., <code>&lt;length&gt;</code>, <code>&lt;color&gt;</code>). It's the contract for what the function provides.</li>
                <li><strong><code>result: ...</code></strong>: This is the <strong>implementation</strong>. It's a mandatory descriptor inside the function's body that defines the <em>actual value</em> the function calculates and sends back. This is where the logic happens.</li>
            </ul>
            <h4>Implementation Status in Chrome</h4>
            <p>It is crucial to understand that the current implementation is experimental and does not yet support the full specification. Here's a breakdown:</p>
            <div class="not-prose grid grid-cols-1 md:grid-cols-2 gap-4 my-4">
                <div class="bg-green-50 border border-green-200 rounded-lg p-4">
                    <h5 class="text-lg font-bold text-green-800">✅ Supported:</h5>
                    <ul class="list-disc list-inside text-green-700 mt-2">
                        <li>Basic function definition</li>
                        <li>Positional arguments</li>
                        <li>The `result` descriptor</li>
                    </ul>
                </div>
                <div class="bg-red-50 border border-red-200 rounded-lg p-4">
                    <h5 class="text-lg font-bold text-red-800">❌ Not Yet Supported:</h5>
                    <ul class="list-disc list-inside text-red-700 mt-2">
                        <li>Typed parameters (`<length>`, etc.)</li>
                        <li>Default values (`--arg = 2px`)</li>
                        <li>The `returns` keyword</li>
                        <li>Named arguments when calling</li>
                    </ul>
                </div>
            </div>
            <h4>Working Example</h4>
            <p>Here is a function that constructs a border. Because of the current implementation status, it uses only the supported features: it requires all arguments to be passed in the correct order.</p>
<pre><code class="language-css">
@function --create-styled-border(--width, --style, --color) {
    result: var(--width) var(--style) var(--color);
}

/* Call with all arguments in order. */
.element-1 {
    border: --create-styled-border(2px, solid, crimson);
}

/* Call with different arguments. */
.element-2 {
    border: --create-styled-border(5px, dashed, limegreen);
}
</code></pre>
            <div class="not-prose space-y-4 mt-4">
                <div class="styled-border-example-1 p-4 rounded-lg bg-gray-50">This box has a 2px solid crimson border.</div>
                <div class="styled-border-example-2 p-4 rounded-lg bg-gray-50">This box has a 5px dashed limegreen border.</div>
            </div>
        </section>

        <section class="mb-12">
            <h3>Fallbacks for Unsupported Browsers</h3>
            <p>Since <code>@function</code> is experimental, you must provide fallbacks. There are two primary methods for this.</p>
            <h4>1. Using the Cascade</h4>
            <p>The simplest method is to rely on the CSS cascade. Define a standard CSS property first, then redefine it with your <code>@function</code>. Browsers that don't understand <code>@function</code> will simply ignore the second rule and use the first one they understood.</p>
<pre><code class="language-css">
.element {
  /* Fallback for older browsers */
  --border-color: #cc0000; 

  /* Modern browsers will use this */
  --border-color: --generate-shade(crimson, 10%);
}
</code></pre>
            <h4>2. Using a Feature Query (`@supports`)</h4>
            <p>For more complex scenarios, you can use an <code>@supports</code> query to check if the browser supports the <code>function()</code> syntax. This is the most robust method for applying styles only when the feature is available.</p>
<pre><code class="language-css">
/* Default styles for all browsers */
.another-element {
    --padding-large: 32px;
}

/* Apply function-based styles only if @function is supported */
@supports function(--any-name(initial)) {
    .another-element {
        --padding-large: --calculate-spacing(var(--base-spacing), 2);
    }
}
</code></pre>
        </section>

        <!-- Section 2: Interactive Themer -->
        <section class="mb-12 not-prose">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">Example 1: The Themer</h2>
            <p class="text-gray-700 mb-6">
                Here, we define two functions, <code>--generate-shade</code> and <code>--generate-tint</code>, to create variations of a base color. The function calculates these values once when the page first loads.
            </p>
            
<pre><code class="language-css">
@function --generate-shade(--base-color, --percentage) {
    result: color-mix(in srgb, var(--base-color), black var(--percentage));
}

/* Usage */
.themed {
    --primary-color-dark: --generate-shade(var(--base-color), 20%);
}
</code></pre>

            <div class="flex items-center my-6">
                <label class="mr-4 font-medium text-gray-700">Base Color:</label>
                <div class="w-12 h-12 rounded-lg border border-gray-300" style="background-color: var(--base-color);"></div>
            </div>

            <div id="themed-container" class="grid grid-cols-1 md:grid-cols-4 gap-4 text-white text-center font-medium themed">
                <div class="p-8 rounded-lg" style="background-color: var(--primary-color-dark)">Dark Shade</div>
                <div class="p-8 rounded-lg" style="background-color: var(--primary-color)">Base Color</div>
                <div class="p-8 rounded-lg" style="background-color: var(--primary-color-light)">Light Tint</div>
                <div class="p-8 rounded-lg border border-gray-200" style="background-color: var(--primary-color-lighter)">Lighter Tint</div>
            </div>

            <div class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <h3 class="text-xl font-semibold text-blue-800">Key Concept: Parse-Time vs. Real-Time</h3>
                <p class="text-blue-700 mt-2">
                    The reason the tints and shades don't update is fundamental to how `@function` currently works. The browser evaluates a `@function` only once, when it first parses the CSS file. It calculates the result based on the initial value of `--base-color` and then treats it as a static, fixed value.
                </p>
                <p class="text-blue-700 mt-2">
                    It is <strong>not reactive</strong>. Unlike `calc()` or standard CSS variables, it does not automatically re-calculate its value when the variables it depends on are changed by JavaScript. This makes it ideal for setting up a static design system but not for building dynamic, interactive components like this themer.
                </p>
            </div>
        </section>


        <!-- Section 3: Dynamic Spacing -->
        <section class="mb-12 not-prose">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">Example 2: Spacing System</h2>
            <p class="text-gray-700 mb-6">
                This example defines a <code>--calculate-spacing</code> function. As with the color themer, this function is only evaluated once when the CSS is parsed.
            </p>

<pre><code class="language-css">
@function --calculate-spacing(--base-unit, --multiplier) {
    result: calc(var(--base-unit) * var(--multiplier));
}

.dynamic-spacing {
    --spacing-sm: --calculate-spacing(var(--base-spacing), 0.5);
    --spacing-lg: --calculate-spacing(var(--base-spacing), 2);
}
</code></pre>

            <div class="flex items-center my-6">
                <label class="mr-4 font-medium text-gray-700">Base Spacing:</label>
                <div class="px-3 py-1 rounded-md bg-gray-200 text-gray-800 font-mono">1rem (16px)</div>
            </div>

            <div class="bg-gray-100 p-4 rounded-lg space-y-4 dynamic-spacing">
                <div class="bg-blue-200 p-2 rounded" style="margin-bottom: var(--spacing-sm);">Small Margin Bottom</div>
                <div class="bg-green-200 p-2 rounded" style="padding: var(--spacing-md);">Medium Padding</div>
                <div class="bg-purple-200 p-2 rounded" style="margin: var(--spacing-lg);">Large Margin</div>
                <div class="bg-pink-200 p-2 rounded" style="padding: var(--spacing-xl);">Extra Large Padding</div>
            </div>
            
            <div class="mt-6 p-4 bg-blue-50 border border-blue-200 rounded-lg">
                <h3 class="text-xl font-semibold text-blue-800">Key Concept: Parse-Time vs. Real-Time</h3>
                <p class="text-blue-700 mt-2">
                    This example demonstrates the same principle as the themer. Even though the function's result contains `calc()`, the entire function is resolved to a static value (e.g., `8px`) during the initial CSS parsing. It does not remain a "live" calculation.
                </p>
            </div>
        </section>

        <!-- Section 4: Fluid Typography -->
        <section class="not-prose">
            <h2 class="text-3xl font-bold text-gray-800 mb-4">Example 3: Fluid Typography</h2>
            <p class="text-gray-700 mb-6">
                Our <code>--fluid-typography</code> function makes responsive text easy. The interactivity here comes from the browser itself. <strong>To see it work, resize the container by dragging its bottom-right corner, or resize your entire browser window.</strong>
            </p>

<pre><code class="language-css">
@function --fluid-typography(--min-size, --max-size, --min-vw, --max-vw) {
    result: clamp(var(--min-size),
                   calc(var(--min-size) + (var(--max-size) - var(--min-size)) * ((100vw - var(--min-vw)) / (var(--max-vw) - var(--min-vw)))),
                   var(--max-size));
}
</code></pre>

            <div class="fluid-text-container bg-gray-800 text-white p-8 rounded-lg overflow-hidden resize-x mt-6" style="min-width: 320px;">
                <h3 class="font-bold">This text scales fluidly!</h3>
            </div>
            
            <div class="mt-6 p-4 bg-green-50 border border-green-200 rounded-lg">
                <h3 class="text-xl font-semibold text-green-800">Key Concept: Returning a Dynamic Function</h3>
                <p class="text-green-700 mt-2">
                    This example <strong>is interactive</strong> because the `@function` returns a `clamp()` expression that contains `vw` (viewport width) units. The browser is built to re-evaluate functions like `clamp()` and `calc()` whenever the viewport size changes.
                </p>
                <p class="text-green-700 mt-2">
                    The `@function` is still only parsed once, but the complex `clamp()` expression it produces remains "live" and responsive to browser resizing. This is a perfect use case for `@function`: simplifying complex, but inherently dynamic, CSS logic.
                </p>
            </div>
        </section>

    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
	<script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
        // No JavaScript is needed for these demos.
    </script>
</body>
</html>
