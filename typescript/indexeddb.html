<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive IndexedDB Guide</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Added Tailwind Typography Plugin -->
    <script src="https://cdn.tailwindcss.com?plugins=typography"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <!-- PrismJS CSS for syntax highlighting -->
    <link href="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/themes/prism-okaidia.min.css" rel="stylesheet">
    <style>
      html {
            scroll-behavior: smooth;
        }
        body {
            font-family: 'Inter', sans-serif;
        }
        .recipe-card {
            page-break-inside: avoid;
            break-inside: avoid;
        }
        /* Custom styles for PrismJS to match the theme */
        .code-block {
            background-color: #2d2d2d; /* A dark background for the code blocks */
            padding: 1rem;
            border-radius: 0.5rem;
            overflow-x: auto;
            font-family: 'Courier New', Courier, monospace;
        }
        pre[class*="language-"] {
            background: transparent;
            margin: 0;
            padding: 0;
        }
    </style>
  </head>
  <body class="bg-gray-100 text-gray-800">
    <div class="container mx-auto p-4 md:p-8 max-w-7xl">
      <header class="text-center mb-12">
        <h1 class="text-5xl font-bold text-gray-900">The Ultimate Interactive Guide to IndexedDB</h1>
        <p class="text-xl text-gray-600 mt-4">Learn by doing with a live recipe book example.</p>
      </header>
      <div class="flex flex-col lg:flex-row lg:space-x-8">
        <!-- Sticky Navigation -->
        <nav class="lg:w-1/4 xl:w-1/5 mb-8 lg:mb-0">
          <div class="sticky top-8 bg-white p-4 rounded-lg shadow-md">
            <h3 class="font-bold text-lg mb-4">On this page</h3>
            <ul class="space-y-2">
              <li><a href="#core-concepts" class="text-indigo-600 hover:underline">Core Concepts</a></li>
              <li><a href="#opening-db" class="text-indigo-600 hover:underline">1. Opening a Database</a></li>
              <li><a href="#live-example" class="text-indigo-600 hover:underline">Live Example</a></li>
              <li><a href="#crud-ops" class="text-indigo-600 hover:underline">2. CRUD Operations</a></li>
              <li><a href="#storage-limits" class="text-indigo-600 hover:underline">3. Storage Limits</a></li>
              <li><a href="#idb-library" class="text-indigo-600 hover:underline">4. The `idb` Library</a></li>
              <li><a href="#comparison" class="text-indigo-600 hover:underline">5. Comparison with WASM DBs</a></li>
            </ul>
          </div>
        </nav>
        <!-- Main Content -->
        <main class="flex-1">
          <article class="prose lg:prose-xl max-w-none space-y-12">
            <section id="core-concepts">
              <h2>Core Concepts</h2>
              <p>Before we dive into the code, let's understand the fundamental principles of IndexedDB:</p>
              <ul>
                <li><strong>Asynchronous API:</strong>
                  Nearly all IndexedDB operations are asynchronous. You request an operation, and the result is delivered to an event handler. This non-blocking nature is essential for web performance.</li>
                <li><strong>Transactional Database:</strong>
                  All data operations happen within a transaction. This ensures data integrity. If one step fails, the entire transaction is rolled back.</li>
                <li><strong>Object-Oriented:</strong>
                  IndexedDB is a NoSQL, object-oriented database. Instead of tables with rows and columns, you have "object stores" that hold key-value pairs.</li>
                <li><strong>Same-Origin Policy:</strong>
                  IndexedDB is tied to a specific origin (protocol, domain, and port). Each origin has its own set of databases.</li>
              </ul>
            </section>
            <section id="opening-db">
              <h2>1. Opening a Database</h2>
              <p>The first step is to open a connection. The `indexedDB.open()` method takes a database name and a version number. The version is crucial; incrementing it triggers the `onupgradeneeded` event, which is the only place you can alter the database's structure (like creating object stores or indexes).</p>
              <div class="code-block">
                <pre><code class="language-javascript">
const request = indexedDB.open('RecipeBookDB', 1);

request.onerror = (event) => {
  console.error(`Database error: ${event.target.errorCode}`);
};

request.onsuccess = (event) => {
  db = event.target.result;
  // Database is open, now we can query it
};

request.onupgradeneeded = (event) => {
  const db = event.target.result;
  const objectStore = db.createObjectStore('recipes', { keyPath: 'id', autoIncrement: true });
  objectStore.createIndex('name', 'name', { unique: false });
};
</code></pre>
              </div>
            </section>
            <!-- Interactive Example Section -->
            <section id="live-example" class="bg-white p-8 rounded-lg shadow-lg not-prose">
              <h2 class="text-3xl font-bold text-center mb-8">Live Recipe Database Example</h2>
              <div class="bg-gray-50 p-6 rounded-lg shadow-inner mb-8">
                <h3 id="form-title" class="text-2xl font-semibold mb-4">Add a New Recipe</h3>
                <form id="recipe-form" class="space-y-4">
                  <input type="hidden" id="recipe-id">
                  <div>
                    <label for="recipe-name" class="block text-sm font-medium text-gray-700">Recipe Name</label>
                    <input type="text" id="recipe-name" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm" required>
                  </div>
                  <div>
                    <label for="ingredients" class="block text-sm font-medium text-gray-700">Ingredients (one per line)</label>
                    <textarea id="ingredients" rows="4" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm" required></textarea>
                  </div>
                  <div>
                    <label for="instructions" class="block text-sm font-medium text-gray-700">Instructions (one per line)</label>
                    <textarea id="instructions" rows="6" class="mt-1 block w-full px-3 py-2 bg-white border border-gray-300 rounded-md shadow-sm" required></textarea>
                  </div>
                  <div class="flex items-center justify-end space-x-4">
                    <button type="button" id="cancel-edit" class="hidden px-4 py-2 border rounded-md text-sm font-medium">Cancel</button>
                    <button type="submit" id="submit-button" class="px-4 py-2 border rounded-md text-sm font-medium text-white bg-indigo-600 hover:bg-indigo-700">Add Recipe</button>
                  </div>
                </form>
              </div>
              <div>
                <h3 class="text-2xl font-semibold mb-4">Saved Recipes</h3>
                <div id="recipe-list" class="space-y-6">
                  <p class="text-gray-500">No recipes saved yet. Add one above!</p>
                </div>
              </div>
            </section>
            <section id="crud-ops">
              <h2>2. CRUD Operations</h2>
              <p>All data operations must be performed within a transaction. You create a transaction, get a reference to your object store, and then perform the desired operation.</p>
              <h3>Adding & Updating Data</h3>
              <p>The `add()` method adds a new object, while `put()` will either add a new object or update an existing one if the key already exists. This is why our form can handle both creating and editing.</p>
              <div class="code-block">
                <pre><code class="language-javascript">
function addOrUpdateRecipe(event) {
    // ... (get form data)
    const transaction = db.transaction(['recipes'], 'readwrite');
    const objectStore = transaction.objectStore('recipes');
    
    // If we have an ID, it's an update (put), 
    // otherwise it's a new item (add).
    const request = id ? objectStore.put(recipe) : objectStore.add(recipe);

    request.onsuccess = () => {
        displayRecipes(); // Refresh the list
    };
}
</code></pre>
              </div>
              <h3>Reading & Deleting Data</h3>
              <p>To read all data, `getAll()` is the most efficient method. For deleting, you simply call `delete()` with the key of the item you want to remove.</p>
              <div class="code-block">
                <pre><code class="language-javascript">
function displayRecipes() {
    const objectStore = db.transaction('recipes').objectStore('recipes');
    const request = objectStore.getAll();
    // ... (display logic in onsuccess)
}

function deleteRecipe(id) {
    const request = db.transaction(['recipes'], 'readwrite')
                      .objectStore('recipes')
                      .delete(id);
    request.onsuccess = () => {
        displayRecipes(); // Refresh the list
    };
}
</code></pre>
              </div>
            </section>
            <section id="storage-limits">
              <h2>3. Storage Limits & Persistence</h2>
              <p>IndexedDB offers a large amount of storage, but it's not infinite. The exact limit depends on the browser and the user's device storage. Generally, browsers allocate a quota based on a percentage of the total disk space (e.g., Chrome might allow up to 60% of disk space for its entire profile).</p>
              <p>However, this storage is considered "temporary" by default. If the user's device runs low on space, the browser may automatically clear your database without warning! To prevent this, you can request
                <strong>persistent storage</strong>.</p>
              <div class="code-block">
                <pre><code class="language-javascript">
async function requestPersistence() {
  if (navigator.storage && navigator.storage.persist) {
    const isPersisted = await navigator.storage.persisted();
    console.log(`Persisted storage granted: ${isPersisted}`);
    if (!isPersisted) {
      const granted = await navigator.storage.persist();
      console.log(`Newly granted persisted storage: ${granted}`);
    }
  }
}

// Call this function early in your app's lifecycle
requestPersistence();
</code></pre>
              </div>
              <p>If the user grants permission, the browser will protect your data from automatic eviction, making it much more reliable for offline applications.</p>
            </section>
            <section id="idb-library">
              <h2>4. Simplifying with the `idb` Library</h2>
              <p>The native IndexedDB API is powerful but very verbose due to its reliance on event handlers and callbacks. The
                <a href="https://github.com/jakearchibald/idb" target="_blank" class="text-indigo-600 hover:underline">`idb` library</a>
                by Jake Archibald is a tiny, promise-based wrapper that makes the API much more ergonomic and compatible with modern `async/await` syntax.</p>
              <p>Instead of nested callbacks, you can write clean, linear code. Compare getting an item natively versus with `idb`:</p>
              <div class="code-block">
                <pre><code class="language-javascript">
// With the idb library (using async/await)
import { openDB } from 'idb';

async function getRecipe(id) {
  const db = await openDB('RecipeBookDB', 1);
  const recipe = await db.get('recipes', id);
  return recipe;
}

// The native way (with callbacks)
function getRecipeNative(id, callback) {
  const request = indexedDB.open('RecipeBookDB', 1);
  request.onsuccess = (event) => {
    const db = event.target.result;
    const transaction = db.transaction('recipes', 'readonly');
    const store = transaction.objectStore('recipes');
    const getRequest = store.get(id);
    getRequest.onsuccess = () => {
      callback(getRequest.result);
    };
  };
}
</code></pre>
              </div>
              <p>Using a library like `idb` is highly recommended for any non-trivial application to improve code readability and maintainability.</p>
            </section>
            <section id="comparison">
              <h2>5. Comparison with WASM Databases (SQLite & pg-lite)</h2>
              <p>While IndexedDB is the native browser database, WebAssembly (WASM) has enabled powerful, server-grade databases like SQLite and PostgreSQL to run directly in the browser. Hereâ€™s how they compare:</p>
              <div class="overflow-x-auto">
                <table>
                  <thead>
                    <tr>
                      <th>Feature</th>
                      <th>IndexedDB / `idb`</th>
                      <th>SQLite (WASM)</th>
                      <th>pg-lite (PostgreSQL WASM)</th>
                    </tr>
                  </thead>
                  <tbody>
                    <tr>
                      <td><strong>Database Model</strong></td>
                      <td>NoSQL (Key-Value / Object)</td>
                      <td>Relational (SQL)</td>
                      <td>Relational (SQL)</td>
                    </tr>
                    <tr>
                      <td><strong>Query Language</strong></td>
                      <td>JavaScript API</td>
                      <td>SQL</td>
                      <td>SQL (PostgreSQL dialect)</td>
                    </tr>
                    <tr>
                      <td><strong>Bundle Size</strong></td>
                      <td>None (Native API)</td>
                      <td>~400-500 KB</td>
                      <td>~1-2 MB+</td>
                    </tr>
                    <tr>
                      <td><strong>Best For</strong></td>
                      <td>Offline-first apps, caching JSON, simple to medium complexity data.</td>
                      <td>Complex relational queries (JOINs), porting existing SQL apps, in-browser analytics.</td>
                      <td>Porting complex server apps that rely on specific PostgreSQL features.</td>
                    </tr>
                  </tbody>
                </table>
              </div>
              <h3>When to Choose Which?</h3>
              <ul>
                <li><strong>Use IndexedDB / `idb`</strong>
                  when you need a lightweight, native solution for storing JavaScript objects. It's perfect for progressive web apps (PWAs) and caching server data for offline use.</li>
                <li><strong>Use SQLite (WASM)</strong>
                  when your application requires complex relational data modeling, you need to perform `JOIN`s across tables, or you are porting an existing application that already uses SQLite. It brings the power of a true SQL database to the client.</li>
                <li><strong>Use `pg-lite`</strong>
                  for niche cases where you need to run an application that specifically depends on PostgreSQL features (like extensions or advanced data types) in the browser. Its larger size makes it less suitable for general-purpose client-side storage.</li>
              </ul>
              <h3>Mitigating Bundle Size with Service Workers</h3>
              <p><strong>Yes, you can absolutely offset the large initial download size of WASM databases by caching them with a service worker.</strong>
                This is a common and highly effective strategy.</p>
              <p>The process works like this: on the user's first visit, the service worker fetches the large WASM file from the network and stores it in the Cache API. On all subsequent visits, the service worker intercepts the request and serves the file directly from the cache, skipping the network entirely. This makes the application load almost instantly after the first time. While this doesn't eliminate the initial download cost, it makes the experience for returning users significantly better and is a key technique for building high-performance, offline-capable applications with these powerful tools.</p>
            </section>
          </article>
        </main>
      </div>
    </div>
    <!-- PrismJS Scripts -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/components/prism-core.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/prism/1.29.0/plugins/autoloader/prism-autoloader.min.js"></script>
    <script>
      // --- IndexedDB Setup ---
        let db;
        const dbName = 'RecipeBookDB_Interactive';
        const dbVersion = 1;

        const request = indexedDB.open(dbName, dbVersion);

        request.onerror = (event) => console.error(`Database error: ${event.target.errorCode}`);
        request.onsuccess = (event) => {
            db = event.target.result;
            console.log('Database opened successfully.');
            displayRecipes();
        };
        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            const objectStore = db.createObjectStore('recipes', { keyPath: 'id', autoIncrement: true });
            objectStore.createIndex('name', 'name', { unique: false });
            console.log('Object store and index created.');
        };

        // --- DOM Elements ---
        const form = document.getElementById('recipe-form');
        const recipeIdInput = document.getElementById('recipe-id');
        const recipeNameInput = document.getElementById('recipe-name');
        const ingredientsInput = document.getElementById('ingredients');
        const instructionsInput = document.getElementById('instructions');
        const recipeList = document.getElementById('recipe-list');
        const submitButton = document.getElementById('submit-button');
        const cancelEditButton = document.getElementById('cancel-edit');
        const formTitle = document.getElementById('form-title');

        // --- Functions for DB Operations ---
        function addOrUpdateRecipe(event) {
            event.preventDefault();
            const recipe = {
                name: recipeNameInput.value,
                ingredients: ingredientsInput.value,
                instructions: instructionsInput.value,
            };
            const transaction = db.transaction(['recipes'], 'readwrite');
            const objectStore = transaction.objectStore('recipes');
            const id = parseInt(recipeIdInput.value);
            let request;
            if (id) {
                recipe.id = id;
                request = objectStore.put(recipe);
            } else {
                request = objectStore.add(recipe);
            }
            request.onsuccess = () => {
                clearForm();
                displayRecipes();
            };
            request.onerror = (event) => console.error('Error saving recipe:', event.target.error);
        }

        function displayRecipes() {
            if (!db) return;
            const transaction = db.transaction(['recipes'], 'readonly');
            const objectStore = transaction.objectStore('recipes');
            const request = objectStore.getAll();

            request.onsuccess = (event) => {
                const recipes = event.target.result;
                recipeList.innerHTML = ''; 

                if (recipes.length === 0) {
                    recipeList.innerHTML = '<p class="text-gray-500">No recipes saved yet. Add one above!</p>';
                    return;
                }

                recipes.forEach(recipe => {
                    const ingredientsHtml = recipe.ingredients.split('\n').map(item => `<li>${item.trim()}</li>`).join('');
                    const instructionsHtml = recipe.instructions.split('\n').map(item => `<li>${item.trim()}</li>`).join('');
                    const recipeCard = document.createElement('div');
                    recipeCard.className = 'recipe-card border border-gray-200 p-4 rounded-lg bg-white';
                    recipeCard.innerHTML = `
                        <h3 class="text-xl font-bold mb-2">${recipe.name}</h3>
                        <div class="grid md:grid-cols-2 gap-4">
                            <div>
                                <h4 class="font-semibold mb-1">Ingredients</h4>
                                <ul class="list-disc list-inside text-gray-600">${ingredientsHtml}</ul>
                            </div>
                            <div>
                                <h4 class="font-semibold mb-1">Instructions</h4>
                                <ol class="list-decimal list-inside text-gray-600">${instructionsHtml}</ol>
                            </div>
                        </div>
                        <div class="mt-4 flex space-x-2 justify-end">
                            <button class="edit-btn px-3 py-1 text-sm font-medium text-indigo-600 hover:text-indigo-900" data-id="${recipe.id}">Edit</button>
                            <button class="delete-btn px-3 py-1 text-sm font-medium text-red-600 hover:text-red-900" data-id="${recipe.id}">Delete</button>
                        </div>
                    `;
                    recipeList.appendChild(recipeCard);
                });
            };
            request.onerror = (event) => console.error('Error fetching recipes:', event.target.error);
        }

        function deleteRecipe(id) {
            const transaction = db.transaction(['recipes'], 'readwrite');
            const objectStore = transaction.objectStore('recipes');
            const request = objectStore.delete(id);
            request.onsuccess = () => displayRecipes();
            request.onerror = (event) => console.error('Error deleting recipe:', event.target.error);
        }

        function editRecipe(id) {
            const transaction = db.transaction(['recipes'], 'readonly');
            const objectStore = transaction.objectStore('recipes');
            const request = objectStore.get(id);
            request.onsuccess = (event) => {
                const recipe = event.target.result;
                recipeIdInput.value = recipe.id;
                recipeNameInput.value = recipe.name;
                ingredientsInput.value = recipe.ingredients;
                instructionsInput.value = recipe.instructions;
                formTitle.textContent = 'Edit Recipe';
                submitButton.textContent = 'Update Recipe';
                cancelEditButton.classList.remove('hidden');
                document.getElementById('live-example').scrollIntoView();
            };
            request.onerror = (event) => console.error('Error fetching recipe for edit:', event.target.error);
        }
        
        function clearForm() {
            form.reset();
            recipeIdInput.value = '';
            formTitle.textContent = 'Add a New Recipe';
            submitButton.textContent = 'Add Recipe';
            cancelEditButton.classList.add('hidden');
        }

        // --- Event Listeners ---
        form.addEventListener('submit', addOrUpdateRecipe);
        recipeList.addEventListener('click', (event) => {
            if (event.target.classList.contains('delete-btn')) {
                const id = Number(event.target.dataset.id);
                if (confirm('Are you sure you want to delete this recipe?')) {
                    deleteRecipe(id);
                }
            }
            if (event.target.classList.contains('edit-btn')) {
                const id = Number(event.target.dataset.id);
                editRecipe(id);
            }
        });
        cancelEditButton.addEventListener('click', clearForm);
    </script>
  </body>
</html>